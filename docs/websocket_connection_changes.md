# WebSocket 前后端连接细节（旧版 vs 新版）

## 旧版实现（问题版本）

### 连接与通信流程
1. **握手**：前端调用 `/ws/recognize`，连接建立后立即发送 `{"type": "config", ...}`。
2. **音频推流**：配置消息之后，前端持续发送 32-bit float PCM 二进制帧。
3. **服务器行为**：
   - 主循环 `while True` 直接调用 `receive_bytes()`，没有超时/休眠。
   - 每收到一帧就 `np.concatenate` 到一个全量 numpy 缓冲区，再进行 VAD 和识别。
   - 没有心跳或空闲检测；即使客户端断电/网络断开，后端也会继续无限循环。

### 前端约束与风险
- 不说话或暂时停止推流时，服务器仍会不停 `receive_bytes()`，出现异常后立即重试，导致 100% CPU 占用。
- 缓冲区无限增长：通话越久，拼接数组越大，前端即便正常推流也会拖慢服务器。
- 客户端异常断开时，后端没有主动清理，可能一直占用连接 slot。

## 新版实现（优化版本）

### 连接与通信流程
1. **握手**：与旧版相同，仍需在连接建立后先发送配置消息。
2. **音频推流**：
   - 前端可继续发送 32-bit float PCM 帧；推荐保持稳定的帧率（例如每 20–30ms 一帧）。
   - 若暂时无语音，请继续发送静音帧，或至少提供 heartbeat。
3. **服务器行为变更**：
   - `receive_bytes()` 包裹 `asyncio.wait_for`，`recv_timeout`≈2s。超时后进入 idle 分支并 `await asyncio.sleep()`，避免 CPU 空转。
   - 使用基于 `deque` 的环形缓冲，只保存最近 `N` 秒音频，避免 `np.concatenate` 复制整个数组。
   - 引入 `last_activity`（音频或 pong）时间戳：间隔超过 `idle_timeout`≈10s 时发送断开通知，随后关闭连接。
   - 定时发送 `ping`，未在 `pong_timeout`≈3s 内收到响应也会关闭连接。

### 前端约束与交互
- **静默超时**：如果用户连续约 10 秒没有发送音频帧（包括静音帧）或没有响应 pong，后端将发送 `timeout`/`idle` 状态并关闭连接。需要在 UI 中提示用户重新开始或继续推流。
- **心跳配合**：当后端发出 `{"type":"ping"}` 时，前端需回 `{"type":"pong"}`（或直接使用 WebSocket pong 帧）。否则 3 秒后会被判定为掉线。
- **资源释放**：连接关闭后请主动重新建立，再发送配置与音频。

### 兼容性建议
- 若前端无法持续发送静音帧，可在长静默前向用户提示“通话已暂停，保持超过 10 秒会断开”。也可以将 `idle_timeout` 调整到更高值，但须前后端同步。
- 保持原有消息协议（config/partial/final/error），新流程只增加了 `ping/pong` 与 `timeout` 状态，不影响已有解析逻辑。

通过上述改动，后端在没有音频/心跳时会主动腾出 CPU 并清理僵尸连接，避免长时间通话导致的性能问题。
